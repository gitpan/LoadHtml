<HTML>
<HEAD>

	<META NAME="CONTACT" CONTENT="Turner, Jim">

	<META NAME="SENSITIVITY" CONTENT="UNRESTRICTED">
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.03 [en] (X11; I; SunOS 5.5.1 sun4u) [Netscape]">
   <TITLE>The LoadHtml Home Page</TITLE>
</HEAD>
<BODY TEXT="#FFFFFF" BGCOLOR="#1000A0" LINK="#E0E000" VLINK="#EFF0B0">
<CENTER>
<!--VirtualAvenueBanner-->
<FONT SIZE=-2>>The above advertising and any auxillary popup windows do NOT reflect the actual opinions of the owner(s) 
of this website nor do we endorse any products or services mentioned, in that 
the content of the adds is beyond our control, but are required by the 
company which hosts this site.  Direct all comments or complaints to them 
(<A HREF="http://www.virtualave.com">http://www.virtualave.com</A>)</FONT>
</CENTER>


<DIV ALIGN=right><I><FONT SIZE=-1>Updated: 09/07/2007</FONT></I></DIV>

<HR WIDTH="80%" SIZE="5">
<H1>
<I>The LoadHtml Home Page</I></H1></CENTER>

<HR WIDTH="80%" SIZE="5">
<CENTER>
<H3>
LoadHtml - Dynamic HTML Generation Library, by Jim
Turner (turnerjw784 att yahoo .dot. com).</H3></CENTER>
LoadHtml is a Perl library to enable Perl CGI programs to dynamically generate
HTML pages from HTML page templates.&nbsp; LoadHtml includes the following
special features:
<UL>
<UL>
<LI>
<FONT COLOR="#FFDEAD">I) Special, nestable HTML control statements
(IF-THEN-ELSE, LOOP, INCLUDE, SELECTLIST, etc.)!</FONT></LI>

<LI>
<FONT COLOR="#FFDEAD">II) HTML templates can be valid
stand-alone HTML pages (with default values) for rapid prototyping.</FONT></LI>

<LI>
<FONT COLOR="#FFDEAD">III) Perl code and variables
can be optionally embedded or prohibited for security reasons on a page-by-page
basis</FONT>.</LI>

<LI>
<FONT COLOR="#FFDEAD">IV) HTML pages can be generated
and later displayed or saved using the "buildhtml" function</FONT>.</LI>

<LI>
<FONT COLOR="#FFDEAD">V) Easy table and select construct
creation using Perl lists and hashes.</FONT></LI>
<LI>

<FONT COLOR="#FFDEAD">VI) Multiple ways to drive loops (by arrays, hashes, traditional 
Perl/C FOR loops, ie. &quot;1 to 100 by 5&quot;.</FONT></LI>

</UL>
</UL>
LoadHtml is written completely in <A HREF="http://www.perl.org">Perl</A>,
a modern, high-performance scripting language.&nbsp; CGI web applications
are completely portable across all platforms which support Perl and CGI,
including Unix and Windows.

<P>Click for <A HREF="#Requirements">System Requirements</A>.

<H3>
<A NAME="SYNOPSIS"></A><FONT COLOR="#FFDEAD">I) Synopsis.</FONT></H3>

use LoadHtml;
<br>print "Content-type: text/html", "\n";
<br>&loadhtml('mytemplate_file.html',
<br>    -ascalararg => 'Display this string',
<br>    -anarrayarg => ['string1', 'string2', 'string3'],
<br>    -ahasharg => {'key1' => 10, 'key2' => 20, 'key3' => 30},
<br>    -amatrix => [[1, 2, 3], [4, 5, 6]]
<br>);

<H3>
<A NAME="OVERVIEW"></A><FONT COLOR="#FFDEAD">II) Overview / User-callable Functions.</FONT></H3>
The following functions are user-callable:

<P>loadhtml($htmlfile,@args)
<BR>$htmlstring = buildhtml($htmlfile,@args)
<BR>AllowEvals(1|0)
<BR>set_poc($poc_name)
<BR>SetRegices()
<BR>SetListSeperator($separator_string)
<BR>SetHtmlHome($htmlhome, $roothtmlhome, $hrefhtmlhome, $hrefcase)
<BR>loadhtml_package($package_name)

<P>The Perl CGI program calls <B>loadhtml</B> when it is ready to generate
an HTML page.&nbsp; The 1st argument is the path and file-name of the html
template file to be used to generate the page.&nbsp; The remaining arguments
are the data values to be substituted in the html page based on special
HTML codes within the template page before the final page is displayed.&nbsp;
When loadhtml is called, the template html file is loaded and parsed, all
argument/parameter substitutions are made, all dynamic html is generated,
and the final html is sent to the browser to be displayed.&nbsp; NOTE:&nbsp;
It is the calling program's responisibility to print any needed HTML headers
BEFORE calling loadhtml.

<P>By default, embedded perl code and variables in HTML templates are not
evaluated for security reasons.&nbsp; To enable loadhtml to process these,
first call "<B>AllowEvals</B>(1)".&nbsp; To turn back off, call "<B>AllowEvals(</B>0)".

<P>Call "<B>set_poc</B>" at the beginning of your CGI script to set a point-of-contact
name to be displayed on any error screens generated by LoadHtml.

<P>By default, any Perl list argements passed to loadhtml, where the corresponding
html code in the template file is not within a "LOOP" or "SELECTLIST" construct,
will print out all values of the list separated by a comma followed by
a space.&nbsp; Call "SetListSeperator" to change this string to something
else.&nbsp; Within the "LOOP" and "SELECTLIST" constructs, html is dynamically
generated for each element within the resulting list.
<BR>&nbsp;
<H3>
<A NAME="recmanip"></A><FONT COLOR="#FFDEAD">III) Parameter Substitution
and Special HTML Control Statements.</FONT></H3>
loadhtml is called with the 1st argument being the filename of the HTML
template file to load.&nbsp; Each subsequent argument corresponds to a
data-value to be added to the HTML via parameter substitution.&nbsp; The
simplest parameter substitution is accomplished by placing the argument
number preceeded by a colon in the desired location for the corresponding
data-value argument in the HTML template file.&nbsp; For example, if an
HTML template file named "myhtml.htm" in directory "/usr/htdocs/" looked
like the following:

<P>&lt;HTML>
<BR>&lt;BR>Roses are :1, violets are :2.&lt;BR>
<BR>&lt;/HTML>

<P>The following call to loadhtml would supply the proper values:

<P>&nbsp;&nbsp;&nbsp; loadhtml('/usr/htdocs/myhtml.htm','red','blue');

<P>and would display the following HTML page:

<P>&lt;HTML>
<BR>&lt;BR>Roses are red, violets are blue.&lt;BR>
<BR>&lt;/HTML>

<P>":1" is replaced by the 1st argument after the file-name, and ":2" with
the second one.

<P><B>NOTE:  It is now possible and preferrable to call loadhtml with NAMED parameters as follows:</B>

<P>The above example using <B>Named Parameters</B>:

<P>&lt;HTML>
<BR>&lt;BR>Roses are &lt;!:roses&gt;, violets are &lt;!:violets:&gt;blue normally&lt;!:/violets&gt;.&lt;BR>
<BR>&lt;/HTML>

<P>The following call to loadhtml would supply the proper values:

<P>&nbsp;&nbsp;&nbsp; loadhtml('/usr/htdocs/myhtml.htm', -roses => 'red', -violets => 'blue');

<P>and would display the same results.  NOTE:  If data is not substituted using 
named parameters, try enclosing each "-parametername" part in single quotes.  Also, 
the format ":{name}" is used in leau of ":number" in the HTML whenever a value 
is to be substituted OUTSIDE of a tag OR within a 'value=":{name}"' part of a tag.  
Otherwise (within tags), just use the format ":name".

<P>NOTE:  In the above example, we show "roses" as a single, unmatched tag.  
"violets" is shown as a matching tag (note the colon before the closeing &gt;).  
The text in between (&quot;blue normally&quot;) is the default text and is shown 
if the page is not browsed via LoadHtml.

<P>Now, suppose we want the HTML page to function as a stand-alone page
without being called by a CGI script, to demo to a customer before writing
the script, you could write:

<P>&lt;HTML>
<BR>&lt;BR>Roses are &lt;:1:>red&lt;:/1>, violets are &lt;:violets:>blue&lt;:/violets>.&lt;BR>
<BR>&lt;/HTML>

<P>This would display the same results as the previous example 
(note the mixing of numbered and named parameters), if the
page is loaded stand-alone directly into the browser, but, if called with:

<P>&nbsp;&nbsp;&nbsp; loadhtml('/usr/htdocs/myhtml.htm','here', -violets => 'there');

<P>would produce the following dynamically-generated page:

<P>&lt;HTML>
<BR>&lt;BR>Roses are here, violets are there.&lt;BR>
<BR>&lt;/HTML>

<P>If no default values are desired, the template file could be written
as:

<P>&lt;HTML>
<BR>&lt;BR>Roses are &lt;!:roses&gt;, violets are &lt;!:violets&gt;.&lt;BR>
<BR>&lt;/HTML>

<P>If a different default value is desired, as when the page is loaded
via LoadHtml, but without a value
<BR>for that specific argument, the template file could be written as:

<P>&lt;HTML>
<BR>&lt;BR>Roses are &lt;:roses=pink:>red&lt;:/roses&gt;, violets are &lt;:violets=violet:&gt;blue&lt;:/violets>.&lt;BR>
<BR>&lt;/HTML>

<P>Now if LoadHtml is called as:

<P>&nbsp;&nbsp;&nbsp; loadhtml('/usr/htdocs/myhtml.htm', -roses => 'scarlet');

<P>The following page would display:

<P>&lt;HTML>
<BR>&lt;BR>Roses are scarlet, violets are violet.&lt;BR>
<BR>&lt;/HTML>
<BR>&nbsp;
<BR><B>Formatting</B>

<P>LoadHtml also supports the "printf" function familiar to C and Perl
programmers for formatting parameter as they are displayed.&nbsp; If this
is not sufficient, user-defined formatting functions are also supported.&nbsp;
For example, to right-justify numeric parameters, one could use the "printf"
formatting characters:&nbsp; "-10.2f" as shown below:

<P>&lt;BR>The results are &lt;!:roses%-10.2f%0.00:&gt;0.00&lt;!:/roses>

<P>This provides that ":1" will be displayed using "printf" formatting,
with defaults of "0.00".

<P>To format currency, one could define a formatting function within the
CGI script to place commas every 3 digits, add parenthesis if negative,
etc.&nbsp; For example:

<P>sub cashit
<BR>{
<BR>&nbsp;my ($val) = shift;
<BR>&nbsp;my ($iter) = shift;
<BR>&nbsp;my ($lastrow) = shift;

<P>&nbsp;$val = sprintf('%.2f',$val);
<BR>&nbsp;$val =~ s/(\d)(\d\d\d)$/$1,$2/;
<BR>&nbsp;$val =~ s/(\d)(\d\d\d),/$1,$2,/g;
<BR>&nbsp;$val = '(' . $val . ')'&nbsp; if ($val =~ s/^\-//);
<BR>&nbsp;return ("$val");
<BR>}

<P>Then include the following in the HTML template:

<P>$&lt;!:amount%&amp;main::cashit% 0:>0&lt;!:/amount>

<P>This formats the dollar amount with commas every three digits and adds
parenthesis if negative.&nbsp; Two decimal places are also displayed.
<BR>&nbsp;

<P>Sometimes, simple parameter substitution is not sufficient.&nbsp; LoadHtml
provides several special control structures to handle more complex dynamic
HTML generation.

<P>An alternate way of specifying parameters (namely, withing HTML tags) is to enclose the 
parameter name between ":{ and "}".  For example:</P>

<P>&lt;A HREF="<!:roses>">Link to Rose colors&lt;/A></P>

<P>would fail since the closing ">" of the parameter would close the &lt;A> tag!  To 
avoid this, specify the parameter as:</P>

<P>&lt;A HREF=":{roses}">Link to Rose colors&lt;/A></P>

<P><B>"IF-THEN-ELSE" statement</B>:

<P>&lt;!IF[statement_name] condition>
<BR>&nbsp;&nbsp;&nbsp; -body-
<BR>&lt;ELSE[statement_name]>
<BR>&nbsp;&nbsp;&nbsp; -body-
<BR>&lt;!/IF[statement_name]>


<P>The "ELSE" part is optional.  The &quot;statement_name&quot; is optional, but should 
always be used if nesting IF statements.  Consider the following HTML template file:

<P>&lt;HTML>
<BR>&lt;H3>Jim's Joke Page!&lt;/H3>
<BR>&lt;BR>
<BR>&lt;!IF :flora =~ /flowers/i>
<BR>&nbsp;&nbsp;&nbsp; &lt;BR&gt;Roses are &lt;!:arg1&gt;, violets are &lt;!:arg2&gt;.&lt;BR&gt;
<BR>&lt;!ELSE>
<BR>&nbsp;&nbsp;&nbsp; &lt;BR&gt;Knock Knock, who's there? &lt;!:arg1&gt;, &lt;!:arg1&gt;
who?, &lt;!:arg2>, that's who!
<BR>&lt;!/IF>
<BR>&lt;/HTML>

<P>This example will generate two different joke-lines, depending on the
value passed as argument #1.

<P>&nbsp;&nbsp;&nbsp; loadhtml('/usr/htdocs/myhtml.htm', -flora => 'FLOWERS', -arg1 => 'red', -arg2 => 'blue');

<P>will produce:

<P>&lt;HTML>
<BR>&lt;H3>Jim's Joke Page!&lt;/H3>
<BR>&lt;BR>
<BR>&lt;BR>Roses are red, violets are blue.
<BR>&lt;/HTML>

<P>whereas:

<P>&nbsp;&nbsp;&nbsp; loadhtml('/usr/htdocs/myhtml.htm', -flora => 'VEGATABLES', -arg1 => 'Foold', -arg2 => 'Fooled
You!');

<P>will produce:

<P>&lt;HTML>
<BR>&lt;H3>Jim's Joke Page!&lt;/H3>
<BR>&lt;BR>
<BR>&lt;BR>Knock Knock, who's there? Foold, Foold who?, Fooled You!, that's
who!
<BR>&lt;/HTML>

<P>NOTE:&nbsp; The "ELSE" portion is not required.
<BR>If one of the parts is desired for a default, the other can be commented
out with HTML comments, for example  (NOTE:  the &quot;statement_name&quot; is included 
and is &quot;_STMT1&quot;:

<P>&lt;!IF_STMT1 :condition>normal text&lt;!ELSE_STMT1>&lt;!-- special-case text -->&lt;!/IF_STMT1>

<P>If invoked as a stand-alone HTML page or if ":condition" is non-null or non-zero,
"normal text" will print, otherwise, "special-case text" will print.&nbsp;
The HTML comments will be removed automatically for the text, if the corresponding
condition evaluates to true.

<P><B>"LOOP" Statement:</B>

<P>Another, more powerful construct is the "LOOP".&nbsp; A LOOP repeatedly
generates its HTML body for each value in a Perl list.&nbsp; The LOOP construct
has the following general format:

<P>&lt;!LOOP[loopname] [first..last[|increment]] [index-list] [list-parm [, listparm...]]>
<BR>&nbsp;&nbsp;&nbsp; -body-
<BR>&lt;!/LOOP[loopname]>

<P>For example:

<P>&lt;HTML>
<BR>&lt;H3>Dallas Cowboy's Star Roster&lt;/H3>
<BR>&lt;P>&lt;TABLE>
<BR>&lt;TR>&lt;TH>No.&lt;/TH>&lt;TH>Name&lt;/TH>&lt;TH>Jersey&lt;/TH>&lt;/TR>
<BR>&lt;!LOOP names, numbers>
<BR>&nbsp;&nbsp;&nbsp; &lt;TR>&lt;TD>:#+1&lt;/TD>&lt;TD>&lt;!:names>&lt;/TD>&lt;TD>&lt;!:numbers>&lt;/TD>&lt;/TR>
<BR>&lt;!/LOOP>
<BR>&lt;/TABLE>
<BR>&lt;/HTML>

<P>If called with:

<P>&nbsp;&nbsp;loadhtml('/usr/htdocs/myhtml.htm', 
<BR>&nbsp;&nbsp;&nbsp; -names => ['Troy Ackman', 'Emmit Smith', 'Michael Irvin'], 
<BR>&nbsp;&nbsp;&nbsp; -numbers => [8,22,88]);

<P>would produce:

<P>&lt;HTML>
<BR>&lt;H3>Dallas Cowboy's Star Roster&lt;/H3>
<BR>&lt;P>&lt;TABLE>
<BR>&lt;TR>&lt;TH>Name&lt;/TH>&lt;TH>Jersey&lt;/TH>&lt;/TR>
<BR>&nbsp;&nbsp;&nbsp; &lt;TR>&lt;TD>1&lt;/TD>&lt;TD>Troy Ackman&lt;/TD>&lt;TD>8&lt;/TD>&lt;/TR>
<BR>&nbsp;&nbsp;&nbsp; &lt;TR>&lt;TD>2&lt;/TD>&lt;TD>Emmit Smith&lt;/TD>&lt;TD>22&lt;/TD>&lt;/TR>
<BR>&nbsp;&nbsp;&nbsp; &lt;TR>&lt;TD>3&lt;/TD>&lt;TD>Michael Irvin&lt;/TD>&lt;TD>88&lt;/TD>&lt;/TR>
<BR>&lt;/TABLE>
<BR>&lt;/HTML>

<P>The values: names, and numbers in the "LOOP" statement refer to those parameters 
which refer to perl list references instead of scaler values.&nbsp; The ":#"
represents a special value -- the iteration number of the loop being processed
(starting with zero).&nbsp; We use ":#+1" to cause this value to start
with one instead of zero). If loops are nested (and thus named, the name
can be appended to the ":# variable, ie:

<P>&lt;!LOOP_LOOPNAME argument1>
<BR>&nbsp;&nbsp;&nbsp; &lt;BR>Now in iteration:&nbsp; :#_LOOPNAME; next arg1 value=&lt;!argument1>
<BR>&lt;!/LOOP_LOOPNAME>

<P>By default, the loop executes with ":#" starting with zero, incrementing
by one and continuing through
<BR>the last value of the 1st list parameter specified.&nbsp; This can
be overridden by specifyingan <B>increment expression</B> with starting and ending values and optionally,
an increment value -OR- an index list.&nbsp; For example (start with 10, stop at 100, and increment by 5):

<P>&lt;!LOOP 10..100|5 argument1>
<BR>&nbsp;&nbsp;&nbsp; &lt;BR>The list value for argument1[:#] is: &lt;!:argument1>.
<BR>&lt;!/LOOP>

<P>This would produce 19 lines of output, the value printed for ":#" would
be 10, then 15, 20, ...100.&nbsp; The tenth, 15th, 20th, 25th, ... and
100th elements of the list passed as argument 2 to LoadHtml() would be
displayed.&nbsp; If that list contained less than 100 elements, empty strings
would print for the missing elements.&nbsp; This is also useful to reverse
the order of a list, for example:

<P>&lt;!LOOP 20..1|-1>
<BR>&nbsp;&nbsp;&nbsp; ...
<BR>&lt;!/LOOP>
<BR>&nbsp;
<BR>&nbsp;

<P>&lt;!LOOP 1..:argument1 argument2, argument3>
<P>This specifies that the loop should execute argument1 times.  Each iteration will 
correspond to a value of argument2 and argument3 starting with element [1].  
argument1 should contain a scaler integer and argument2 and argument3 should be 
references to arrays with at least "argument1" + 1 elements.</P>

<P>&lt;!LOOP &nbsp;5.. &nbsp;argument2, argument3>
<P>This specifies that the loop should execute once for each element of argument2 
starting with the 6th one ([5]) and continuing through the last one.</P>

<P>&lt;!LOOP 1,5,2,7 argument1, argument2>
<P>This specifies that the loop should execute 4 times using the 2nd, 6th, 3rd, and 8th 
values of argument1 and argument2.</P>

<P>&lt;!LOOP indexlist argument1, argument2>
<P>This specifies that the loop should execute once for each element in the array-reference 
passed to "indexlist".  Each value of indexlist will become the subscript to use for 
argument1 and argument2 in it's respective iteration.</P>

<P>NOTE:  If argument1 is a hash-reference instead of an array-reference, then the 
keys used for argument1 will be based on the relative position within an imaginary 
array built on the fly as "sort(keys(%{$argument1))".  For example if the keys for 
argument1 (sorted) were "AA", "BB", "CC", and "DD"; and array referenced by indexlist contained the values (in this order):  (1, 3, 2, 0), then the loop would iterate through the keys in the order of:  "BB", then "DD", then "CC", and finally "AA".  This allows hashes to be iterated through in an order other than sorted by key!</P>

<P>There are four special variables that have meaning within a loop construct:</P>

<UL>
<LI>:#    Current increment value.  If no increment expression or index list is specified, the loop 
is driven by the 1st array or hash argument.  In that case, the increment value is the 
zero-based iteration of the loop.  This value is always numeric and represents the index 
subscript of the vectors for the current iteration.

<LI>:*    Always the current zero-based iteration of the loop (numeric).

<LI>:%    Current key value of the 1st (driving) hash (if the 1st argument is a hash-reference).  
Otherwise, this variable is empty.

<LI>:^    Always contains the number of iterations (one-based) that the loop will perform.
</UL>

<P>Naming and nesting IF and LOOP constructs.

<P>IF and LOOP constructs can be nested with each other.&nbsp; If nested
within the same construct, however, they must be named (in order for the
parser to match up the proper closing tags).&nbsp; This allows for qualifying the 
special variables (:#, :*, etc.) to the desired loop.  To name an "IF" or "LOOP"
constuct, simply append an alphanumeric string to the keyword, for example:

<P>&lt;!IF2>...&lt;!ELSE2>...&lt;!/IF2>

<P>&nbsp;&nbsp;&nbsp; -or-

<P>&lt;!LOOP_OUTER>...&lt;!/LOOP_OUTER>

<P>The "IF" is named "2", and the "LOOP" "_OUTER".
<BR>&nbsp;

<P>Multi-loop Matrix example:</P>
<P>Consider the following code:</P>
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;my $data = $dbh->selectall_arrayref('select name, address, phone from some_database.table');
<BR>&nbsp;&nbsp;&nbsp;&nbsp;...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&loadhtml('rate_specials.html',
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-colHeaders => [qw(Name Address Phone)],
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-matrix => $data,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-names => '$matrix->[*][0]',   #THIS IS AN EXAMPLE OF A COLUMN &quot;Slice&quot;!
<br>&nbsp;&nbsp;&nbsp;&nbsp;);
</P>

<P>Now consider the following template code:</P>

<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;table&gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TR class="heading"&gt;&lt;TH&gt;Link&lt;/TH&gt;&lt;!LOOP_HEADERS colHeaders&gt;&lt;TH&gt;&lt;!:colHeaders:&gt;Field&nbsp;Header&lt;!:/colHeaders&gt;&lt;/TH&gt;&lt;!/LOOP_HEADERS&gt;&lt;/TR&gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!LOOP_ROWS matrix, names&gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!IF_ODDEVEN1 :#_ROWS % 2&gt;&lt;TR class="oddrow"&gt;&lt;!ELSE_ODDEVEN1&gt;&lt;TR class="evenrow"&gt;&lt;!/IF_ODDEVEN1&gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD align="center"&gt;&lt;A HREF="cgi-bin/someotherpgm.cgi?name=:{names}"&gt;&lt;!:names&gt;&lt;/A&gt;&lt;/td&gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!LOOP_COLS matrix&gt;&lt;TD&gt;&lt;!:matrix:&gt;Field&nbsp;Value&lt;!:/matrix&gt;&lt;/TD&gt;&lt;!/LOOP_COLS&gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TR&gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!/LOOP_ROWS&gt;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/table&gt;
<BR>
</P>

<P>This illustrates how simple it is to combine LoadHTML with DBI (the single call to 
DBI::selectall_arrayref fetches all the data from a database query into a two-dimentional 
<b>row-major</B> array referenced by $data).  This HTML template could handle a veriety 
of queries, since the number of columns (headers) is driven by a loop.  The "ODDEVEN1" 
IF-statement is optional and simply allows the table rows to have different colors for readability.
Note the nexted loops "_ROWS" (outer) and "_COLS" (inner), both are driven by the array-
referencing parameter "matrix".  This will produce a table showing a row for each record 
read by the query and each row will contain all three column values.  </P>

<P>An extra, but 
unnecessary level of complexity was added to this example to illustrate another feature - 
the column "slice".  Note the 1st column header is "Link", and the 1st column of each 
row is a link to "someotherpgm.cgi".  The reason for this is to show access to the entire 
column "names".  By specifying an additional parameter called "-names" containing the 
literal value &quot;$matrix->[*][0]&quot;.  This means that the "names" parameter refers 
to the 1st ([0]'th) slice of the array referenced by the "matrix" parameter.  For each 
row in the loop, the asterisk is replaced by the increment number, so that in the 1st row 
"names" refers to $data->[0][0] (The 1st name returned by the query).  In the 2nd row, 
"names" refers to $data->[1][0], etc.  This permits the row-major data returned by the query 
to be handled in a column-major way (allowing the programmer to get at the individual 
elements of a specified column).

<P>Note also, that is is not limited to 2 dimensions or to array-references.  The number 
of dimensions is not physically limited, but can be any number and combination of 
array and or hash-references.  The trick is that there must be a nested loop refering to 
the same parameter for each dimension to be unrolled.  When hash-references are used, 
they are sorted by key.</P>

<P><B>"SELECTLIST" Statement</B>:

<P>Another compound construct is the "SELECTLIST".&nbsp; It generates an
HTML "SELECT" statement using the elements of a Perl list or hash, generating
an "OPTION" line for each element in the list or hash.&nbsp; The general
format is:

<P>&lt;!SELECTLIST NAME=select_name [VALUE[S]=value_list] [DEFAULT[SEL]=default_value]
 [(BYKEY)|BYVALUE] [REVERSE[D]] :list_parameter>
<BR>&nbsp;&nbsp;&nbsp; [...HTML to display if page invoked standalone...]
<BR>&lt;!/SELECTLIST>

<P>The NAME and any options other than "VALUE" or "DEFAULT" are added to
the generated SELECT statement.&nbsp; The "list_parameter" (required),
by default, becomes the values for the generated "OPTION" lines.&nbsp;
If "list_parameter" is a Perl hash, then the keys of the hash become the
arguments for the "VALUE=" part of each OPTION line, and the values become
the displayed items in the listbox.  The values are then character-sorted by 
key (BYKEY) unless "BYVALUE" is specified.  "REVERSE" reversed the order.  
&nbsp; If "list_parameter" is a list 
and a second list is supplied via the "VALUE" option, then the second list
becomes the "VALUE=" part of each OPTION line and the "list_parameter"
list items are displayed.  They are displayed in the order they appear in the 
list(s), unless "REVERSE" is specified.  &nbsp;
If no "VALUE" option is given and "list_parameter" 
is a list, then no "VALUE=" option is generated and the values become both
the actual values and the displayed values for the listbox.&nbsp; The DEFAULT
option, if specified, is a value which is to be the initially highlighted
value in the select-list.  &nbsp;If the "MULTIPLE" select option is specified, 
then the "DEFAULT=" value may be either a scalar or list-reference.  Each value 
in the "DEFAULT" list is matched against the "VALUE" list and those that match 
are "SELECTED" by default.  If "DEFAULTSEL=" is specified, the default list 
values are compared with the SELECT values instead the "VALUES" values.  &nbsp;
Note that the resulting selection-list
items are sorted in character-sequence order when the list parameter is a hash&nbsp;
To get a true numeric sort, one must left-pad the hash keys with spaces.&nbsp;
Example:

<P>&lt;!SELECTLIST NAME=id DEFAULT=":1" :2>&lt;INPUT NAME=id TYPE=TEXT>&lt;!/SELECTLIST>

<P>...

<P>&nbsp;&nbsp;&nbsp; $mydefault = 123;
<BR>&nbsp;&nbsp;&nbsp; %idhash = (110 => 'John Smith', 145 => 'Richard
Adams', 123 => 'Mike Cox', 132 => 'Eddy Jones');
<BR>&nbsp;&nbsp;&nbsp; &amp;loadhtml('/usr/htdocs/myhtml.htm', $mydefault,
\%idhash);

<P>This would produce the following HTML:

<P>&lt;SELECT NAME=id>
<BR>&nbsp;&nbsp;&nbsp; &lt;OPTION VALUE="110">John Smith
<BR>&nbsp;&nbsp;&nbsp; &lt;OPTION SELECTED VALUE="123">Mike Cox
<BR>&nbsp;&nbsp;&nbsp; &lt;OPTION VALUE="132">Eddy Jones
<BR>&nbsp;&nbsp;&nbsp; &lt;OPTION VALUE="145">Richard Adams
<BR>&lt;/SELECT>
<BR>&nbsp;

<P><B>Checkboxes and radio-buttons:</B>

<P>Checkboxes and radio-buttons also require special handling.&nbsp; A
default value is specified in the HTML via a parameter.&nbsp; The parameter
will be replaced by the word "CHECKED" if it's value matches the value
specified for the checkbox or radio-button.&nbsp; for example:

<P>&lt;BR>&lt;INPUT TYPE=CHECKBOX NAME="checkit" :1>Check here if True!&lt;BR>

<P>If the value passed to ":1" is "true" in Perl (not zero, empty string,
or whitespace), the HTML will be generated with ":1" replaced with the
word "CHECKED", otherwise, the ":1" it will be removed.  NOTE:  If the word 
"CHECKED" is already in the HTML, it will be removed if the value for ":1" is 
false, but will remain if no argument is <I>defined</I> for ":1".

<P>&lt;INPUT TYPE=RADIO NAME="topings" VALUE="meat" :1>Give me Meat and
Cheese
<BR>&lt;INPUT TYPE=RADIO NAME="topings" VALUE="veggies" :1>Give me Veggies,
please

<P>If the argument passed to ":1" is equal 'meat' or 'veggies', then the
corresponding radio-button will be marked "CHECKED", otherwise, neither
will be checked.
<BR>&nbsp;

<P><B>"INCLUDE" statement</B>:

<P>Additional HTML files can be loaded and processed within an HTML file
via the "INCLUDE" statement.&nbsp; All files loaded via the "INCLUDE" statement
are also parsed and modified the same way the initial HTML file is.&nbsp;
The include file can be specified as either a server file-name or a url.&nbsp;
Examples:

<P>&lt;!INCLUDE /user/htdocs>
<BR>&lt;!INCLUDE http://domain/path/myhtml.htm>
<BR>&nbsp;

<P>You can also include a portion of another html template file without including the 
endire file by using tags</P>

<P>For example:</P>

<P>&lt;!INCLUDE http://domain/path/myhtml.htm:header>

<P>This assumes the template file myhtml.htm contains the following block tag:</P>

<P>&lt;!-- BEGIN header -->
<BR>... stuff to be included ...
<BR>&lt;!-- END header -->
</P>

<P>You can also force different default values for parameters by including them 
in the include, ie.:</P>

<P>&lt;!INCLUDE http://domain/path/myhtml.htm:header(roses=red,violets=blue)> -or-
<BR>&lt;!INCLUDE /user/htdocs(arg1=:{another_arg})>
</P>

<P>Providing default values for form items.

<P>LoadHtml provides special ways to assign default values to HTML "INPUT"
statements.&nbsp; Consider the following for putting a default value into
a TEXT field:

<P>&nbsp;&nbsp;&nbsp; &lt;INPUT NAME=name TYPE=TEXT VALUE=":1">

<P>This will work, but LoadHtml provides a better way.&nbsp; If done this
way and the form is invoked stand-alone, the input box will show a literal
":1", which is probably not desired for demos.&nbsp; The preferred way
is:

<P>&nbsp;&nbsp;&nbsp; &lt;INPUT NAME=name TYPE=TEXT VALUE="standalone-default"
:1=default>

<P>This provides a value "standalone-default", if the page is invoked as
stand-alone HTML and a value of "default", if no argument or "undef" is
passed for the corresponding argument.&nbsp; If the "=default" string is
omitted, the box will show as empty, if no argument is passed for ":1".&nbsp;
NOTE:&nbsp; If an empty string is passed as an argument, the box will be
empty regardless of any default values specified!&nbsp; This option also
applies to "HIDDEN" input fields.

<P>&nbsp;&nbsp;&nbsp; &lt;SELECT NAME=myselect :1>...&lt;/SELECT>

<P>This permits the default (initially highlighted) value of the SELECT
statement to be specified by argument 1.

<P>&nbsp;&nbsp;&nbsp; &lt;TEXTAREA... :1=default>stand-alone default&lt;/TEXTAREA>

<P>This works similar to the "&lt;INPUT TYPE=TEXT...>" input field described
previously.
<BR>&nbsp;

<P><B>Other special tags</B>:


<P><B>Embedding Perl variables</B>:

<P>If "AllowEvals(1)" is called before calling "loadhtml", then any embedded
Perl variables of the format:&nbsp; ":$scaler&nbsp; or :$array[index] or
:$hash{index} or :$package::variable&nbsp; will be replaced by it's value
current at the time LoadHtml is called.

<P><B>Embedding Perl code (the "EVAL" Statement)</B>:

<P>If "AllowEvals(1)" is called before calling "loadhtml", then any Perl
code between the tag: "&lt;!EVAL.../EVAL>" will be evaluated and any returned
results will replace the EVAL tag.&nbsp; Consider the following example:

<P>&nbsp;&nbsp;&nbsp;&nbsp; &lt;!EVAL
<BR>&nbsp;&nbsp;&nbsp; my (@t) = localtime(time);
<BR>&nbsp;&nbsp;&nbsp; return ($t[3] . '-' . (qw(JAN FEB MAR APR MAY JUN
JUL AUG SEP OCT NOV DEC))[$t[4]] . '-' .&nbsp; $t[5] . '.');
<BR>&nbsp;&nbsp;&nbsp; /EVAL>

<P>This tiny Perl program calls Perl's "localtime" function, and returns
the current date with the month formated into it's proper three-character
abbreviation.&nbsp; The more complicated example below generates a dynamic
url link:

<P>&nbsp;&nbsp;&nbsp; &lt;!EVAL
<BR>&nbsp;&nbsp;&nbsp; my ($homepage) = ":0";
<BR>&nbsp;&nbsp;&nbsp; $homepage =~ s/userpage/pp:4/;
<BR>&nbsp;&nbsp;&nbsp; if (-e "$homepage")
<BR>&nbsp;&nbsp;&nbsp; {
<BR>&nbsp;&nbsp;&nbsp; $homepage = 'http://myhost.domain.com/cgi-bin/loadtext.pl?link='
<BR>&nbsp;&nbsp;&nbsp; . $homepage . '&amp;args=:1,:2,:3,:4,:5,:6,:7,:8,:9,:10,:11,:12,:13,:14,:15,:16,:17,:18,:19,:20,:21,:22';
<BR>&nbsp;&nbsp;&nbsp; return ('&lt;CENTER&amp;gt&lt;BR&amp;gt&lt;A HREF='
. $homepage . '&amp;gtGo to my Personal Homepage&lt;/A&amp;gt&lt;/CENTER&amp;gt&lt;BR&amp;gt&lt;HR
SIZE=5&amp;gt');
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; /EVAL>

<P>Note that parameter substitutions take place within this code.&nbsp;
Also note the use of "&amp;gt" in lieu of the ">" symbol.&nbsp; This is
required to prevent the HTML processor from closing the "&lt;!EVAL" tag
before the end of the "EVAL" code!&nbsp; The special parameter ":0" contains
the name of the html template file.
<BR>&nbsp;

<P><B>Embedding hash-definitions within HTML pages</B>:

<P>Hash tables can now be defined within an HTML page for creating lookup tables, etc.
  To create a hash table, use the "<!HASH> tag.  For example:

<P>
&lt;!HASH attbdescs>
<BR>'any' => 'Any attribute',
<BR>'di' => 'Direct/Indirect',
<BR>'dgr' => 'Education (Degree)',
<BR>'ins' => 'Education (Institution)',
<BR>'maj' => 'Education (Major)',
<BR>'exl' => 'Experience (LM)',
<BR>'ex' => 'Experience (Total)',
<BR>'flv' => 'Foreign Language',
<BR>'flw' => 'Foreign Language',
<BR>'fpt' => 'Full/Part Time',
<BR>'ou' => 'Organization',
<BR>'pos' => 'Title',
<BR>'sg' => 'Salary Grade',
<BR>'sc' => 'Security Clearance',
<BR>'sk' => 'Skills and Knowledge',
<BR>'tr' => 'Training'
<BR>&lt;!/HASH attbdescs>
<BR><P>
This defines a lookup table for several codes and gives each a description. The hash 
can be any valid Perl hash-definition.   
The hash will be referred to within the HTML by the name "attbdescs".  To cause a
hash's value to be displayed, use its name in the special tag in the format:  
<P>&nbsp;&nbsp;&nbsp; &lt;!%hashname{key}default>
<P>For example to display the following tag:
<P>&nbsp;&nbsp;&nbsp; &lt;!%attbdescs{pos}>
<P>would be replaced with "Title".  The real use for this is specifying the key 
dynamically, ie:  
<P>&nbsp;&nbsp;&nbsp; &lt;!%attbdescs{:1}-NO SUCH VALUE!->
<P>The result depends on the value of ":1".  If the value of ":1" does not match any 
of the key values, then "-NO SUCH VALUE!-> is displayed.
<P>If the template page is also being used stand-alone, the entire hash definition 
(between "&lt;!HASH...>" and "&lt;!/HASH>) can be enclosed as a comment ("&lt!-- ... -->").

<H3>
&nbsp;<A NAME="Functions"></A><FONT COLOR="#FFDEAD">IV). User-callable Functions:</FONT></H3>

<P><B>loadhtml($htmlfile, @args)</B></P>

<P>Main function to read/process a specified template file / url ($htmlfile) and prints 
out the resulting html page to STDOUT.  @args represents a list of values.  Each argument 
value replaces any occurrance of the corresponding parameter number (ie. ":1", ":2", etc.).  
If the first, third, fifth, etc. are valid Perl "words" starting with a hyphen, then the 
next argument (ie. the 2nd, fourth, sixth, etc.) represents a value that will replace 
every occurrance of the parameter with the same name, ie. "-parm => 'value', converts 
:{parm} or &lt;!:parm> or &lt;!:parm:>...&lt;!:/parm> to 'value' everywhere it occurrs.  
For each parameter that is used in a LOOP or SELECTLIST construct, the value should be 
an array reference or a hash referehce, rather than a scalar value.  If successful, 
loadhtml returns 1 (true) if fails, ie. could not open the template file, &lt;undef>.  
The special parameter ":0" is replaced with the name of the template file (1st argument).
</P>

<P><B>loadhtml($htmlfile, @args);</B></P>

<P>&nbsp;&nbsp;&nbsp;&nbsp;is equivalent to:</P>

<P>print buildhtml($htmlfile, @args);</P>

<P><B>buildhtml($htmlfile, @args);</B></P>

<P>Same as loadhtml, except returns the generated webpage as a string instead of writing 
it to STDOUT;

<P><B>AllowEvals(1|0);</B></P>

<P>Toggles whether or not embedded Perl variables and expressions are performed, namely 
the &lt;!PERL> and &lt;EVAL> constructs and Perl variables in the format: "&lt;!:$variable>".</P>
Default is 0.

<P><B>set_poc($str);</B></P>

<P>Sets the string to replace the special "&lt;POCS>" construct.  Default is to ignore this 
tag.  If called without a string or an empty string, the string is set to 
"your website administrator".</P>

<P><B>SetRegices(%optionshash);</B></P>

<P>Sets special control options.  The currently defined options (with their default values) 
are:  -hashes => 0, -CGIScript => 0, -includes => 1, -embeds => 0, -loops => 1, 
-numbers => 1, -pocs => 0, -perls => 0)</P>

<P>These options allow speeding up processing when turned off (not needed).  
<P>-hashes:  Allows the &lt;!HASH> tag sto be processed if on, otherwise ignored.</P>
<P>-CGIScript:  Causes s special hidden form variable called "CGIScript" to be added at 
the bottom of the first form with the value set to "$ENV{SCRIPT_NAME}" if on, otherwise not added.</P>
<P>-includes:  Allows the &lt;!INCLUDE> tags to be processed if on, otherwise ignored.</P>
<P>-embeds:  Allows the &lt;!EMBED> tags to be processed if on, otherwise ignored.</P>
<P>-loops:  Allows the &lt;!LOOP> tags to be processed if on, otherwise ignored.</P>
<P>-numbers:  Allows the classic numeric parameter (":1", ":2", etc.) tags to be processed if on, otherwise ignored.</P>
<P>-pocs:  Allows the &lt;!POC> tags to be processed if on, otherwise ignored.</P>
<P>-perls:  Allows the &lt;!PERL> tags to be processed if on, otherwise ignored.</P>

<P><B>SetListSeperator($separator_string);</B></P>

<P>Sets the separator string to be used if an array-reference is passed to a parameter 
that appears outside of a loop (where a scalar value is expected)  Such values are 
automatically converted to a string of values ala Perl's "join()" function.  The default 
string is ", ".</P>

<P><B>SetHtmlHome($htmlhome, $roothtmlhome, $hrefhtmlhome, $hrefcase);</B></P>

<P>This allows certain embedded links within a document to be "converted" for proper 
handling.  Relative links refer to a different path when the document is loaded via 
CGI/LoadHTML than then they are loaded directly as urls by a browser, for example, the 
document root usually becomes the directory the CGI script is in.  Anyway, this is 
an attempt to allow valid HTML pages to also be loaded as templates within a CGI script 
and maintain their links properly.</P>

<P>$htmlhome - specifies the URL path to append to relative links in SRC=, HREF=, CL=, HT=, GROUND=, 
and window.open() arguments.</P>

<P>$roothtmlhome specifies the filesystem path to append to relative file names in &lt;INCLUDE> tags.</P>

<P>$hrefhtmlhome - similar to $htmlhome, but only applies to HREF= links, if it is 
necessary to redirect them to a different path, ie. a cgi-script for pre-processing.  
If both $hrefhtmlhome and $htmlhome are specified and non-empty, the former will override 
for HREF= links and the other will applie to the other link types, ie. SRC=, etc.</P>

<P>$hrefcase - used to limit the substitutions of $htmlhome and $hrefhtmlhome to specific 
links.  It can be set to 'l' (Lower-case links only), left undefined for all links, or 
set to anything else for Upper-case links only.  For purposes of case, a "Lower-case" link 
would be "href=", an "Upper-case" link would be "HREF=".</P>

<P><B>loadhtml_package($package_name);</B></P>

<P>Change the default package LoadHTML uses for embedded Perl variables.  Default is main.  
Best way to set this is to call "loadhtml_package(__PACKAGE__);".</P>


<H3>
&nbsp;<A NAME="Requirements"></A><FONT COLOR="#FFDEAD">V). Minimum System
Requirements:</FONT></H3>

<UL>1) Any system supporting Perl and CGI.

<P>2) <A HREF="ftp://ftp.digital.com/pub/plan/perl/CPAN/src/">Perl, v.
5.003</A> or better.

<P>3) Perl's "LWP" module and required prerequesites:&nbsp; MIME-Base64
(MIME), HTML-Parser (HTML), libnet (Net), MD5, and Data-Dumper (Data).&nbsp;
All of these are available for download from <A HREF="ftp://ftp.metronet.com/pub/perl/modules/by-module">CPAN</A>.
</P>

<P>
<HR WIDTH="80%" SIZE="5"></UL>
&nbsp;<IMG SRC="http://turnerville.wwol.com/cgi-bin/access_log.pl?LoadHtml">

</BODY>
</HTML>
